# Research & Replay Architecture (The Silas Standard)

## 1. Philosophy: The Log IS the Database

In the `chronicle-rs` ecosystem, we reject the traditional separation between "Live Trading" and "Historical Research".
- **Live:** The Feed Handler writes binary events to memory-mapped segments.
- **Research:** The Replay Engine maps those *exact same segments* to reconstruct the past.

**We do not use SQL or generic NoSQL for high-frequency data.**
Why?
1.  **Fidelity:** Databases destroy wire-level nuances (sequence gaps, packet fragmentation, exact hardware timestamps).
2.  **Latency:** ETL processes introduce delays and translation errors.
3.  **Redundancy:** Storing the data twice (Log + DB) is wasteful.

## 2. Architecture: Deterministic Event Sourcing

The Replay Engine is a **state machine** where $State_{t+1} = f(State_t, Event_t)$.

### 2.1 Components

1.  **Source (Chronicle Reader):**
    -   Iterates over persisted `.q` files.
    -   Mode: `StartMode::Earliest` (for full rebuild) or `StartMode::ResumeSnapshot`.
    -   Access: Zero-Copy (casts raw bytes to Event structs).

2.  **State (The L3 Book):**
    -   An in-memory reconstruction of the Limit Order Book.
    -   Tracks every single order (L3), not just price levels (L2).

3.  **Clock (Time Hijacking):**
    -   The Replay Engine **ignores the system clock**.
    -   Time is purely a function of `message.timestamp_ns` (Ingest Time) and `event.exchange_ts` (Matching Engine Time).
    -   Strategies act on "Event Time", ensuring backtests are reproducible regardless of hardware speed.

### 2.2 The Replay Loop (Pseudocode)

```rust
// The loop must be tight and allocation-free.
while let Some(msg) = reader.next() {
    // 1. Integrity Check (The "Gap" Obsession)
    if msg.seq != last_seq + 1 {
        panic!("SEQUENCE GAP: {} -> {}. Market state invalid.", last_seq, msg.seq);
    }
    
    // 2. State Update
    let event = msg.as_event(); // Zero-copy cast
    book.apply(event);
    
    // 3. Strategy Hook
    strategy.on_event(&book, event);
    
    last_seq = msg.seq;
}
```

## 3. L3 Order Book Reconstruction

To match the matching engine, we must track individual orders.

### 3.1 Data Structures

```rust
struct L3Book {
    // O(1) access to modify/cancel specific orders
    orders: HashMap<u128, OrderNode>, // Key: OrderID

    // Sorted access for "Best Bid/Ask" and impact cost calculation
    // Using BTreeMap for simplicity, or a custom Red-Black tree for perf
    bids: BTreeMap<u64, Level>, // Key: Price (descending)
    asks: BTreeMap<u64, Level>, // Key: Price (ascending)
}

struct OrderNode {
    price: u64,
    size: u64,
    side: Side,
    // Pointers for intrusive linked list within the Level?
}
```

### 3.2 Event Logic

*   **ADD:**
    1.  Create `OrderNode`.
    2.  Insert into `orders` HashMap.
    3.  Find/Create `Level` in `bids`/`asks`.
    4.  Add size to `Level`.

*   **CANCEL (Partial or Full):**
    1.  Lookup `OrderNode` in `orders`.
    2.  Decrement size in `Level`.
    3.  If size == 0, remove `OrderNode` and cleanup `Level`.

*   **EXECUTE:**
    1.  Treat as Partial Cancel (reduce size).
    2.  Record "Trade" feature for the strategy (volume, aggressor side).

*   **REPLACE (Modify):**
    1.  Atomic `Cancel(Old)` + `Add(New)`.
    2.  **Crucial:** This resets queue priority. The simulation must reflect this loss of priority.

## 4. Snapshots & Warm Starts

Replaying 5 years of ticks to test a strategy on the last 10 minutes is non-viable.

### 4.1 Periodic Snapshots
The system supports "Checkpoints":
-   **Frequency:** e.g., Every midnight UTC or every 10GB of data.
-   **Format:** A serialized dump of the `L3Book` struct (using SBE or raw binary).
-   **Naming:** `snapshot_<seq_num>.bin`.

### 4.2 Resume Protocol
1.  Researcher requests: "Replay from 2023-10-27 09:30:00".
2.  Engine finds latest snapshot *before* that time: `snapshot_10500000.bin`.
3.  Load Snapshot into `L3Book` -> State is now at `Seq 10,500,000`.
4.  Open Chronicle Queue.
5.  Seek/Scan to `Seq 10,500,001`.
6.  Replay fast-forward until `09:30:00`.
7.  Begin Strategy simulation.

## 5. Validation Standards

A replay is only valid if it proves its own integrity.

1.  **Sequence Continuity:**
    -   Must track `last_seq`. Panic on gaps.
    -   Reason: A missing packet means we missed an order. Our book is now crossed or wrong.

2.  **Timestamp Monotonicity:**
    -   `timestamp_ns` (Ingest) should generally increase.
    -   If `exchange_ts` drifts significantly backwards, flag "Clock Skew" or "Reordering".

3.  **State Hashing (Determinism):**
    -   At the end of the day, compute `hash(book)`.
    -   This hash must match the `hash` generated by the production system (if it dumps state) or previous runs.

## 6. Python Integration (The "Analyst" Interface)

While the Core Engine is Rust, researchers live in Python/Jupyter.

**PyO3 Bindings:**
-   Wrap `ReplayEngine` as a Python Class.
-   Expose `next_tick()` iterator.
-   Convert Rust `L3Book` to `numpy` arrays or `pandas` DataFrame on demand (expensive, use sparingly).

```python
# Intended usage
engine = chronicle.ReplayEngine("/data/chronicle/binance_spot", symbol="BTCUSDT")
engine.seek_time("2024-01-20T10:00:00")

for event in engine:
    features = engine.book.get_features() # [spread, imbalance, vwap]
    alpha = my_model.predict(features)
    # ...
```
